<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Autobattler — Two-Screen Sprite-Ready (v2)</title>
<style>
:root{
  --bg:#0b0b0b;--panel:#151515;--text:#eaeaea;--muted:#9aa0a6;--accent:#4dabf7;--accent2:#a78bfa;
  --win:#34d399;--loss:#ef4444;--slot:#1f1f1f;--grid:#2a2a2a;--sel:#3b82f6;--hp:#22c55e;--hpbg:#3a3a3a;
  --enemy:#b45309; --ally:#2563eb;
}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
  font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
.safe{padding-bottom:constant(safe-area-inset-bottom);padding-bottom:env(safe-area-inset-bottom)}
.panel{background:var(--panel);border:1px solid #222;border-radius:12px;padding:10px 12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
.btn{background:#1e1e1e;border:1px solid #333;color:#eaeaea;border-radius:10px;padding:12px 14px;text-align:center;user-select:none}
.btn:active{transform:translateY(1px)}
.small{font-size:12px;color:var(--muted)}
.sep{height:1px;background:#222;margin:6px 0}
.win{color:var(--win)} .loss{color:var(--loss)} .notice{color:#fbbf24}

/* Prep Screen */
#prep{display:grid;grid-template-rows:auto auto 1fr auto;gap:10px;min-height:100vh;padding:10px 14px}
.board{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
.slot{position:relative;background:var(--slot);border:1px dashed var(--grid);border-radius:10px;min-height:64px;display:grid;place-items:center;padding:6px;overflow:hidden}
.slot.sel{outline:2px solid var(--sel); outline-offset:2px;}
.unit{display:grid;gap:2px;place-items:center}
.badge{font:11px ui-monospace,Menlo,Consolas,monospace;color:#111;background:var(--accent);padding:1px 6px;border-radius:999px}
.badge.tank{background:#60a5fa}.badge.ranger{background:#f59e0b}.badge.healer{background:#10b981}.badge.assassin{background:#ef476f}.badge.mage{background:#a78bfa}
.hpbar{position:absolute;left:6px;right:6px;bottom:6px;height:6px;background:var(--hpbg);border-radius:6px;overflow:hidden}
.hpfill{height:100%;background:var(--hp);}
.float{position:absolute;left:50%;transform:translateX(-50%);top:6px;font:12px ui-monospace,Menlo,Consolas,monospace;animation: rise 800ms ease-out forwards;pointer-events:none}
.float.dmg{color:#f87171}.float.heal{color:#34d399}
@keyframes rise{from{opacity:1;transform:translate(-50%,0)}to{opacity:0;transform:translate(-50%,-18px)}}
.row{display:flex;gap:8px;align-items:center;justify-content:space-between}
.shop{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
.controls{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:8px}
.log{font:12px ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;line-height:1.35;max-height:36vh;overflow:auto;background:#0f0f0f;border:1px solid #222;border-radius:10px;padding:10px}

/* Battle Screen */
#battle{display:none;min-height:100vh;padding:10px 14px}
.grid2{display:grid;gap:10px}
.bhud{display:flex;gap:8px;align-items:center;justify-content:space-between}
.field{display:grid;gap:6px}
.line{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
.cell{position:relative;height:88px;background:#111;border:1px solid #222;border-radius:10px;display:grid;place-items:center;overflow:hidden}
.cell .name{position:absolute;top:4px;left:6px;font-size:11px;color:#ddd;opacity:0.9}
.cell .hpbar{position:absolute;left:6px;right:6px;bottom:6px;height:6px;background:#1e1e1e;border-radius:6px;overflow:hidden}
.cell .hpfill{height:100%;background:var(--hp)}
.sprite{width:64px;height:64px;image-rendering: pixelated;background:#2b2b2b;border-radius:8px;display:grid;place-items:center}
.sprite.ally{outline:2px solid var(--ally)} .sprite.enemy{outline:2px solid var(--enemy)}
.action{position:absolute;inset:0;pointer-events:none}
.fx{position:absolute;width:6px;height:6px;background:#fbbf24;border-radius:50%;opacity:0;transition: transform .35s linear, opacity .35s linear}
.fx.show{opacity:1}
.flash{animation: flash .25s ease-out}
@keyframes flash{from{filter:brightness(1.6)}to{filter:brightness(1)}}
.fadeout{animation: fadeout .45s ease forwards}
@keyframes fadeout{to{opacity:0; transform: scale(0.9)}}
</style>
</head>
<body class="safe">

<!-- PREP SCREEN -->
<div id="prep">
  <header>
    <h2 style="margin:0 0 4px">Autobattler — Prep</h2>
    <div class="small">Tap unit → tap slot to move/swap • Merges on 3 copies • Level up to field more units</div>
  </header>

  <section class="panel">
    <div class="row">
      <div><strong>Board</strong> <span class="small">(front row / back row)</span></div>
      <div class="small">Gold: <span id="gold">10</span> • Level: <span id="lvl">3</span> • Units max: <span id="cap">3</span></div>
    </div>
    <div class="board" id="rowF"></div>
    <div class="board" id="rowB"></div>
    <div class="sep"></div>
    <div class="row">
      <div class="small" id="enemyPrev"></div>
      <div class="small">Relics: <span id="relics">Shield @ start</span></div>
    </div>
    <div class="board" id="bench" style="grid-template-columns:repeat(5,1fr)"></div>
  </section>

  <section class="panel">
    <div class="row"><strong>Shop</strong> <span class="small">(tap to buy → bench)</span></div>
    <div class="shop" id="shop"></div>
    <div class="controls">
      <div class="btn" id="reroll">Reroll (2g)</div>
      <div class="btn" id="level">Level Up (4g)</div>
      <div class="btn" id="start">Start Battle</div>
      <div class="btn" id="lock">Lock Shop</div>
    </div>
  </section>

  <section class="panel">
    <div class="row"><strong>Notes</strong></div>
    <div class="log" id="log"></div>
  </section>
</div>

<!-- BATTLE SCREEN -->
<div id="battle">
  <div class="panel grid2">
    <div class="bhud">
      <div><strong>Battle</strong> <span class="small">Wave <span id="bwavenum">1</span></span></div>
      <div class="small">
        <button class="btn" id="bspeed">0.75x</button>
        <button class="btn" id="bquit">Back to Prep</button>
      </div>
    </div>

    <div class="field">
      <div class="small">Enemies</div>
      <div class="line" id="eline"></div>
      <div class="small">Allies</div>
      <div class="line" id="aline"></div>
    </div>
  </div>
</div>

<script>
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;}}
const rng = mulberry32(1337);
function rand(){ return rng(); }
function choice(arr){ return arr[Math.floor(rand()*arr.length)] }

const CLASSES = {
  K:{name:'Knight', cls:'tank', hp:100, atk:10, def:5, spd:1.2, range:'melee'},
  A:{name:'Archer', cls:'ranger', hp:60, atk:15, def:2, spd:0.9, range:'ranged'},
  H:{name:'Healer', cls:'healer', hp:50, atk:5, def:2, spd:1.5, range:'support', heal:15},
  S:{name:'Assassin', cls:'assassin', hp:55, atk:18, def:1, spd:0.8, range:'melee', backstab:true},
  M:{name:'Mage', cls:'mage', hp:55, atk:14, def:1, spd:1.1, range:'ranged', splash:true}
};
const ENEMIES = [
  {name:'Goblins', count:3, hp:40, atk:8, spd:1.2},
  {name:'Wolves', count:4, hp:35, atk:6, spd:0.7},
  {name:'Slime', count:2, hp:80, atk:12, spd:1.3, poison:5},
  {name:'Ogre Chief', count:1, hp:200, atk:20, spd:1.5}
];

const state = {
  gold: 10, level: 3, cap: 3, benchCap: 5, levelCost: 4,
  rowF: [null,null,null,null],
  rowB: [null,null,null,null],
  bench: [null,null,null,null,null],
  relics: ['Shield @ start'],
  wave: 1, inBattle: false, locked: false,
  selected: null
};

function makeUnit(code){
  const base = CLASSES[code];
  return { code, name: base.name, cls: base.cls,
    maxhp: base.hp, hp: base.hp, atk: base.atk, def: base.def, spd: base.spd,
    range: base.range, heal: base.heal||0, backstab: !!base.backstab, splash: !!base.splash,
    tier: 1, copies: 1, stats:{dmg:0, heal:0} };
}
function powerUp(u){ u.tier += 1; u.maxhp = Math.round(u.maxhp * 1.5); u.hp = u.maxhp; u.atk = Math.round(u.atk * 1.5); }

const logEl = document.getElementById('log');
function log(msg, cls=''){ const p=document.createElement('div'); if(cls) p.className=cls; p.textContent=msg; logEl.appendChild(p); logEl.scrollTop=logEl.scrollHeight; }
function clearLog(){ logEl.textContent=''; }
function boardCount(){ return [...state.rowF, ...state.rowB].filter(Boolean).length; }
function sameSel(a,b){ return a && b && a.area===b.area && a.idx===b.idx; }
function getAt(area, idx){ return area==='rowF'?state.rowF[idx] : area==='rowB'?state.rowB[idx] : state.bench[idx]; }
function setAt(area, idx, val){ if(area==='rowF') state.rowF[idx]=val; else if(area==='rowB') state.rowB[idx]=val; else state.bench[idx]=val; }
function icon(u){ return `<div class="unit"><div class="badge ${u?u.cls:''}">${u?u.name: ''}</div><div class="small">${u?('T'+u.tier):''}</div></div>`; }
function floatText(area, idx, text, kind){
  const container = (area==='rowF'?document.getElementById('rowF'): area==='rowB'?document.getElementById('rowB'): document.getElementById('bench'));
  const slot = container.children[idx];
  if(!slot) return;
  const el = document.createElement('div'); el.className='float ' + (kind||''); el.textContent = text;
  slot.appendChild(el); setTimeout(()=>{ if(el.parentNode) el.parentNode.removeChild(el); }, 900);
}

function renderEnemyPreview(){
  const base = ENEMIES[(state.wave-1) % ENEMIES.length];
  const prev = document.getElementById('enemyPrev');
  prev.textContent = `Next: ${base.name} ×${base.count} • HP ${base.hp} • ATK ${base.atk}` + (base.poison?` • Poison ${base.poison}`:'');
}

function renderPrep(){
  const f = document.getElementById('rowF'); f.innerHTML = '';
  const b = document.getElementById('rowB'); b.innerHTML = '';
  const bench = document.getElementById('bench'); bench.innerHTML='';

  function slot(area, i, unit){
    const div=document.createElement('div'); div.className='slot'; if(state.selected && state.selected.area===area && state.selected.idx===i) div.classList.add('sel');
    div.innerHTML = unit?icon(unit):'';
    if(unit){
      const hp = Math.max(0, Math.min(unit.hp, unit.maxhp));
      const pct = Math.round((hp/unit.maxhp)*100);
      const bar = document.createElement('div'); bar.className='hpbar';
      const fill = document.createElement('div'); fill.className='hpfill'; fill.style.width=pct+'%';
      bar.appendChild(fill); div.appendChild(bar);
    }
    div.onclick = ()=> onSlotTap(area, i);
    return div;
  }
  for(let i=0;i<4;i++){ f.appendChild(slot('rowF', i, state.rowF[i])); }
  for(let i=0;i<4;i++){ b.appendChild(slot('rowB', i, state.rowB[i])); }
  for(let i=0;i<state.benchCap;i++){ bench.appendChild(slot('bench', i, state.bench[i])); }

  document.getElementById('gold').textContent = state.gold;
  document.getElementById('lvl').textContent = state.level;
  document.getElementById('cap').textContent = state.cap;
  document.getElementById('relics').textContent = state.relics.join(', ');
  document.getElementById('enemyPrev').textContent = '';
  renderEnemyPreview();
}
function onSlotTap(area, idx){
  const sel = state.selected;
  if(!sel){
    const u = getAt(area, idx); if(!u){ log('Empty slot', 'notice'); return; }
    state.selected = {area, idx}; renderPrep(); return;
  }
  if(sameSel(sel, {area, idx})){ state.selected=null; renderPrep(); return; }
  const fromU = getAt(sel.area, sel.idx);
  const toU = getAt(area, idx);
  if(!fromU){ state.selected=null; renderPrep(); return; }
  const movingIntoBoard = (sel.area==='bench') && (area!=='bench') && !toU;
  if(movingIntoBoard && boardCount() >= state.cap){
    log(`Board is full (${state.cap}). Level up to field more.`, 'loss'); state.selected=null; renderPrep(); return;
  }
  setAt(sel.area, sel.idx, toU);
  setAt(area, idx, fromU);
  state.selected = null; renderPrep();
}

/* Shop */
function rollShop(){
  if(state.locked) return;
  const codes = Object.keys(CLASSES);
  const offers = [choice(codes), choice(codes), choice(codes)];
  const shop = document.getElementById('shop'); shop.innerHTML = '';
  offers.forEach(code => {
    const u = makeUnit(code);
    const btn = document.createElement('div'); btn.className='btn'; btn.innerHTML = `${u.name}<div class="small">${u.cls}</div>`;
    btn.onclick = () => {
      if(state.gold < 3){ log('Not enough gold', 'loss'); return; }
      const idx = state.bench.findIndex(x=>!x);
      if(idx === -1){ log('Bench full', 'loss'); return; }
      state.gold -= 3; addOrMerge(u); renderPrep();
    };
    shop.appendChild(btn);
  });
}
document.getElementById('reroll').onclick = ()=>{
  if(state.gold<2){ log('Not enough gold', 'loss'); return; }
  state.gold -= 2; state.locked=false; rollShop(); renderPrep(); log('Shop rerolled (-2g)');
};
document.getElementById('lock').onclick = ()=>{
  state.locked = !state.locked;
  log(state.locked ? 'Shop locked.' : 'Shop unlocked.');
};
document.getElementById('level').onclick = ()=>{
  if(state.gold < state.levelCost){ log(`Need ${state.levelCost} gold to level.`, 'loss'); return; }
  state.gold -= state.levelCost; state.level += 1; state.cap = Math.min(6, state.cap + 1); state.levelCost += 2;
  renderPrep(); log(`Level up! Now level ${state.level}. Unit cap ${state.cap}.`,'win');
};

function addOrMerge(u){
  const all = [...state.rowF, ...state.rowB, ...state.bench].filter(Boolean);
  const same = all.filter(x=>x.name===u.name && x.tier===u.tier);
  if(same.length >= 2){
    let consumed = 0;
    function removeOne(list){
      for(let i=0;i<list.length;i++){
        if(list[i] && list[i].name===u.name && list[i].tier===u.tier && consumed<2){
          list[i] = null; consumed++;
        }
      }
    }
    removeOne(state.bench); removeOne(state.rowB); removeOne(state.rowF);
    const upgraded = makeUnit(u.code); upgraded.tier=u.tier; upgraded.maxhp=u.maxhp; upgraded.hp=u.maxhp; upgraded.atk=u.atk; upgraded.stats={dmg:0,heal:0};
    powerUp(upgraded);
    const slot = state.bench.findIndex(x=>!x);
    if(slot!==-1) state.bench[slot]=upgraded;
    log(`Merge! ${u.name} → ${u.name}+ (Tier ${upgraded.tier})`, 'win');
  }else{
    const idx = state.bench.findIndex(x=>!x);
    if(idx!==-1) state.bench[idx]=u;
  }
}

/* --------- Battle Screen --------- */
const prepEl = document.getElementById('prep');
const battleEl = document.getElementById('battle');
const eline = document.getElementById('eline');
const aline = document.getElementById('aline');
const bwaveNum = document.getElementById('bwavenum');
const bspeedBtn = document.getElementById('bspeed');
const bquitBtn = document.getElementById('bquit');

let battle = null;
// pacing multiplier to slow down attack intervals
const PACE = 1.35;
let speedOptions = [0.75, 1.0, 1.25];
let si = 0;

function toBattle(){
  const actives = [];
  for(let i=0;i<state.rowF.length;i++){ const u=state.rowF[i]; if(u) actives.push({side:'ally', area:'rowF', idx:i, u}); }
  for(let i=0;i<state.rowB.length;i++){ const u=state.rowB[i]; if(u) actives.push({side:'ally', area:'rowB', idx:i, u}); }
  if(actives.length===0){ log('No units on board!', 'loss'); return; }
  const party = actives.slice(0, state.cap).map(x=>({ side:'ally', area:x.area, idx:x.idx, u: {...x.u, stats:{dmg:0,heal:0}}, t:0, next:x.u.spd*PACE }));
  party.forEach(p => p.u.hp = Math.min(p.u.maxhp+5, p.u.hp+5));

  const base = ENEMIES[(state.wave-1) % ENEMIES.length];
  const mobs = []; for(let i=0;i<base.count;i++){ const mhp = Math.round(base.hp*(1+0.18*(state.wave-1))); mobs.push({ side:'enemy', name:base.name, hp: mhp, maxhp: mhp, atk: Math.round(base.atk*(1+0.12*(state.wave-1))), spd: base.spd, t:0, next:base.spd*PACE }); }
  battle = { waveType: base.name, poison: base.poison||0, party, mobs, t:0, dt:0.08, speed:speedOptions[si], running:true };
  bwaveNum.textContent = state.wave;
  renderField();
  prepEl.style.display='none'; battleEl.style.display='block';
  loopBattle();
}
function toPrep(rewardGold, wasVictory){
  battle = null;
  state.inBattle = false;                // allow starting again
  state.locked = false;                  // unlock shop on return
  if(wasVictory){ 
    state.wave += 1;                     // progress to next wave
    state.gold += (typeof rewardGold==='number'?rewardGold:0);
    // heal board units to 70% min
    for(const u of [...state.rowF, ...state.rowB].filter(Boolean)){ u.hp = Math.max(u.hp, Math.floor(u.maxhp*0.7)); }
    log(`Victory! +${rewardGold||0}g. Advanced to Wave ${state.wave}. Team healed to 70%.`, 'win');
  } else {
    log('Defeat... You can adjust and try again.', 'loss');
  }
  renderPrep();
  rollShop();
  prepEl.style.display='grid'; battleEl.style.display='none';
}

function spriteDiv(side,label){
  const div=document.createElement('div');
  div.className='sprite ' + (side==='ally'?'ally':'enemy');
  div.dataset.label = label;
  return div;
}
function cell(side, label, hp, maxhp){
  const c=document.createElement('div'); c.className='cell';
  const spr=spriteDiv(side,label); c.appendChild(spr);
  const name=document.createElement('div'); name.className='name'; name.textContent=label; c.appendChild(name);
  const hb=document.createElement('div'); hb.className='hpbar'; const fill=document.createElement('div'); fill.className='hpfill'; fill.style.width=Math.max(0,Math.round(100*hp/maxhp))+'%'; hb.appendChild(fill); c.appendChild(hb);
  const fx=document.createElement('div'); fx.className='action'; c.appendChild(fx);
  return {c, spr, hbFill:fill, fx};
}
function renderField(){
  eline.innerHTML=''; aline.innerHTML='';
  for(let i=0;i<4;i++){
    const m = battle.mobs[i];
    if(m){ const {c, spr, hbFill, fx}=cell('enemy', battle.waveType, m.hp, m.maxhp); m._el={c,spr,hbFill,fx}; eline.appendChild(c); }
    else{ const empty=document.createElement('div'); empty.className='cell'; eline.appendChild(empty); }
  }
  for(let i=0;i<4;i++){
    const p = battle.party[i];
    if(p){ const {c, spr, hbFill, fx}=cell('ally', p.u.name, p.u.hp, p.u.maxhp); p._el={c,spr,hbFill,fx}; aline.appendChild(c); }
    else{ const empty=document.createElement('div'); empty.className='cell'; aline.appendChild(empty); }
  }
}

function attackAnim(attacker, target){
  if(attacker && attacker._el){ attacker._el.spr.classList.add('flash'); setTimeout(()=>attacker._el.spr.classList.remove('flash'), 250); }
  if(attacker && target && attacker.side==='ally' && target.side==='enemy'){
    const aRect = attacker._el.c.getBoundingClientRect();
    const tRect = target._el.c.getBoundingClientRect();
    const fx = attacker._el.fx;
    const proj = document.createElement('div'); proj.className='fx show';
    fx.appendChild(proj);
    const dx = (tRect.left + tRect.width/2) - (aRect.left + aRect.width/2);
    const dy = (tRect.top + tRect.height/2) - (aRect.top + aRect.height/2);
    proj.style.transform = 'translate(0,0)';
    requestAnimationFrame(()=>{
      proj.style.transform = `translate(${dx}px, ${dy}px)`;
      setTimeout(()=>{ proj.classList.remove('show'); if(proj.parentNode) proj.parentNode.removeChild(proj); }, 360);
    });
  }
  if(target && target._el){ target._el.spr.classList.add('flash'); setTimeout(()=>target._el.spr.classList.remove('flash'), 250); }
}

function pickAlive(arr){ const alive = arr.filter(x=>x.hp>0); return alive.length ? alive[Math.floor(rand()*alive.length)] : null; }

function loopBattle(){
  if(!battle || !battle.running) return;
  const step = battle.dt * battle.speed;
  battle.t += step;

  if(battle.poison && Math.floor(battle.t)%3===0 && Math.abs(battle.t-Math.floor(battle.t))<1e-9){
    battle.party.forEach(p=>{ if(p.u.hp>0){ p.u.hp -= battle.poison; if(p._el) p._el.hbFill.style.width=Math.max(0,Math.round(100*p.u.hp/p.u.maxhp))+'%'; } });
  }

  for(const p of battle.party){
    if(p.u.hp<=0) continue;
    p.next -= step;
    if(p.next<=0){
      if(p.u.heal){
        const target = battle.party.reduce((a,b)=> (b.u.hp>0 && (!a || b.u.hp<a.u.hp)) ? b : a, null);
        if(target){ const pre=target.u.hp; target.u.hp = Math.min(target.u.maxhp, target.u.hp + p.u.heal); if(target._el) target._el.hbFill.style.width=Math.max(0,Math.round(100*target.u.hp/target.u.maxhp))+'%'; }
      }else{
        const target = pickAlive(battle.mobs);
        if(target){
          let dmg=p.u.atk; if(p.u.backstab) dmg=Math.round(dmg*1.2);
          if(p.u.splash){
            const other = pickAlive(battle.mobs.filter(m=>m!==target));
            target.hp -= dmg; if(other) other.hp -= Math.floor(dmg*0.5);
            if(target._el) target._el.hbFill.style.width=Math.max(0,Math.round(100*target.hp/target.maxhp))+'%';
            if(other && other._el) other._el.hbFill.style.width=Math.max(0,Math.round(100*other.hp/other.maxhp))+'%';
          }else{
            target.hp -= dmg; if(target._el) target._el.hbFill.style.width=Math.max(0,Math.round(100*target.hp/target.maxhp))+'%';
          }
          attackAnim(p, target);
        }
      }
      p.next += p.u.spd*PACE;
    }
  }
  for(const m of battle.mobs){
    if(m.hp<=0) continue;
    m.next -= step;
    if(m.next<=0){
      const target = pickAlive(battle.party.map(x=>x.u));
      if(target){
        target.hp -= m.atk;
        const wrap = battle.party.find(pp=>pp.u===target);
        if(wrap && wrap._el) wrap._el.hbFill.style.width=Math.max(0,Math.round(100*wrap.u.hp/wrap.u.maxhp))+'%';
      }
      m.next += m.spd*PACE;
    }
  }

  for(const m of battle.mobs){
    if(m.hp<=0 && m._el && !m._dead){ m._dead=true; m._el.c.classList.add('fadeout'); }
  }
  for(const p of battle.party){
    if(p.u.hp<=0 && p._el && !p._dead){ p._dead=true; p._el.c.classList.add('fadeout'); }
  }
  battle.mobs = battle.mobs.filter(m=>m.hp>0);

  const partyAlive = battle.party.some(p=>p.u.hp>0);
  const mobsAlive = battle.mobs.length>0;
  if(!partyAlive || !mobsAlive || battle.t>120){
    battle.running=false;
    const victory = (!mobsAlive && partyAlive);
    setTimeout(()=>{
      toPrep(victory?5:0, victory);
    }, 250);
    return;
  }

  requestAnimationFrame(loopBattle);
}

/* Wiring */
const prepEl = document.getElementById('prep');
const battleEl = document.getElementById('battle');
document.getElementById('start').onclick = ()=>{ if(!state.inBattle){ state.inBattle=true; toBattle(); } };
document.getElementById('bquit').onclick = ()=>{ if(battle) battle.running=false; toPrep(0,false); };
const bspeedBtn = document.getElementById('bspeed');
bspeedBtn.onclick = ()=>{ si=(si+1)%speedOptions.length; if(battle) battle.speed=speedOptions[si]; bspeedBtn.textContent = speedOptions[si]+'x'; };

/* Init */
(function init(){
  state.rowF[0] = makeUnit('K');
  state.rowB[1] = makeUnit('A');
  state.bench[0] = makeUnit('H');
  renderPrep(); rollShop(); clearLog();
  log('Prep ready. Arrange units, buy (3g), level up, then Start Battle.');
})();
</script>
</body>
</html>
